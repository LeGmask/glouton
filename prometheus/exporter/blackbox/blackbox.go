package blackbox

import (
	"errors"
	"fmt"
	"glouton/logger"
	"os"
	"sync"

	"github.com/prometheus/blackbox_exporter/config"
	"github.com/prometheus/blackbox_exporter/prober"
	"github.com/prometheus/client_golang/prometheus"
	"gopkg.in/yaml.v3"
)

const namespace = "Blackbox"

var (
	probeSuccessDesc = prometheus.NewDesc(
		prometheus.BuildFQName(namespace, "scrape", "probe_success"),
		"Displays whether or not the probe was a success",
		[]string{"target"},
		nil,
	)
	probeDurationDesc = prometheus.NewDesc(
		prometheus.BuildFQName(namespace, "scrape", "probe_duration_seconds"),
		"Returns how long the probe took to complete in seconds",
		[]string{"target"},
		nil,
	)
	probers = map[string]prober.ProbeFn{
		"http": prober.ProbeHTTP,
		"tcp":  prober.ProbeTCP,
		"icmp": prober.ProbeICMP,
		"dns":  prober.ProbeDNS,
	}
)

// blackboxCollector "encapsulates" all the metrics generated by blackbox_exporter
type blackboxCollector struct {
	collectors map[string]prometheus.Collector
	logger     logger.Logger
}

// Describe implements the prometheus.Collector interface.
func (coll *blackboxCollector) Describe(ch chan<- *prometheus.Desc) {
	ch <- probeSuccessDesc
	ch <- probeDurationDesc
}

// Collect implements the prometheus.Collector interface.
func (coll *blackboxCollector) Collect(ch chan<- prometheus.Metric) {
	wg := sync.WaitGroup{}
	wg.Add(len(coll.collectors))
	for _, c := range coll.collectors {
		go func(c prometheus.Collector) {
			c.Collect(ch)
		}(c)
	}
	wg.Wait()
}

type target struct {
	url     string
	module  config.Module
	timeout int
}

// Describe implements the prometheus.Collector interface.
func (target *target) Describe(ch chan<- *prometheus.Desc) {
	panic(errors.New("The method 'Describe(ch chan<- *prometheus.Desc)' should never be called" +
		" on glouton.prometheus.exporter.blackbox.Target objects."))
}

// Collect implements the prometheus.Collector interface.
func (target *target) Collect(ch chan<- prometheus.Metric) {
	// do the actual "probing"

}

// we do not reuse config.ReloadConfig as we do not need the mutex introduce by config.SafeConfig:
// we assume hot reloads will replace the current collector with a fresh one, thus obviating the
// need for synchronisation, as the configuration is immutable for the lifetime of the collector.
// However, this code is highly inspired from it, so if this breaks, chances are config.ReloadConfig
// was altered, and the fix is there.
func loadConfig(configFile string) (*config.Config, error) {
	conf := &config.Config{}

	yamlReader, err := os.Open(configFile)
	if err != nil {
		return nil, errors.New(fmt.Sprint("Cannot read blackbox_exporter config file:", configFile))
	}
	defer yamlReader.Close()

	decoder := yaml.NewDecoder(yamlReader)
	decoder.KnownFields(true)

	if err := decoder.Decode(conf); err != nil {
		return nil, errors.New(fmt.Sprint("Cannot parse Blackbox_exporter config file:", configFile))
	}

	return conf, nil
}

// NewCollector creates a new collector for Blackbox_exporter
func NewCollector(options Options) (prometheus.Collector, error) {
	// read blackbox_exporter config
	conf, err := loadConfig(options.BlackboxConfigFile)
	if err != nil {
		return nil, err
	}

	unknownModules := []string{}
	collectors := make(map[string]prometheus.Collector)

	for _, curTarget := range options.Targets {
		module, present := conf.Modules[curTarget.ModuleName]
		if !present {
			unknownModules = append(unknownModules, curTarget.ModuleName)
			continue
		}

		timeout := curTarget.Timeout
		if timeout == 0 {
			// set a default timeout of 10s, as we do not have acces to the scrape time, AFAIK ?
			timeout = 10
		}

		collectors[curTarget.URL] = &target{url: curTarget.URL, module: module, timeout: timeout}
	}

	if len(unknownModules) > 0 {
		return nil, fmt.Errorf(`Unknown blackbox modules found in your configuration: %v.\
				Maybe check that these modules are present in your blackbox config file ('%s') ?`,
			unknownModules,
			options.BlackboxConfigFile)
	}

	collector := &blackboxCollector{
		collectors: collectors,
		logger:     logger.V(2),
	}

	return collector, nil
}
