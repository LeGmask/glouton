// Copyright 2015-2023 Bleemeo
//
// bleemeo.com an infrastructure monitoring solution in the Cloud
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vsphere

import (
	"context"
	"fmt"
	"glouton/config"
	"glouton/crashreport"
	"glouton/inputs"
	"glouton/logger"
	"net/url"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/influxdata/telegraf"
)

const (
	KindHost = "HostSystem"
	KindVM   = "VirtualMachine"
)

type Manager struct {
	vSpheres map[string]*vSphere

	l                 sync.Mutex
	lastDevices       []Device
	lastDevicesUpdate time.Time
}

func (m *Manager) RegisterInputs(vSphereCfgs []config.VSphere, registerInput func(name string, input telegraf.Input, opts *inputs.GathererOptions, err error)) {
	m.vSpheres = make(map[string]*vSphere)

	for _, vSphereCfg := range vSphereCfgs {
		u, err := url.Parse(vSphereCfg.URL)
		if err != nil {
			logger.V(1).Printf("Failed to parse vSphere URL %q: %v", vSphereCfg.URL, err)

			continue
		}

		if _, alreadyExists := m.vSpheres[u.Host]; alreadyExists {
			continue
		}

		vSphere := newVSphere(u.Host, vSphereCfg)

		input, opts, err := vSphere.makeInput()
		if err != nil {
			logger.Printf("Failed to create input %s: %v", vSphere.String(), err)

			continue
		}

		registerInput(vSphere.String(), input, opts, err)

		m.vSpheres[u.Host] = vSphere
	}
}

func (m *Manager) Devices(ctx context.Context, maxAge time.Duration) []Device {
	m.l.Lock()
	defer m.l.Unlock()

	if time.Since(m.lastDevicesUpdate) < maxAge {
		return m.lastDevices
	}

	startTime := time.Now()

	deviceChan := make(chan Device)
	wg := new(sync.WaitGroup)

	for _, vSphere := range m.vSpheres {
		vSphere := vSphere

		wg.Add(1)

		go func() {
			defer crashreport.ProcessPanic()

			vSphere.devices(ctx, deviceChan)
			wg.Done()
		}()
	}

	go func() { wg.Wait(); close(deviceChan) }()

	var devices []Device //nolint:prealloc
	var moids []string   //nolint:prealloc,wsl // TODO: remove

	for device := range deviceChan {
		devices = append(devices, device)
		moids = append(moids, device.MOID()) // TODO: remove
	}

	logger.Printf("Found devices: %s", strings.Join(moids, ", ")) // TODO: remove

	printCallStack() // TODO: remove

	m.lastDevices = devices
	m.lastDevicesUpdate = time.Now()

	logger.Printf("vSphere devices discovery done in %s", time.Since(startTime)) // TODO: V(2)

	return devices
}

func printCallStack() {
	for i := 1; i < 15; i++ {
		pc, file, line, ok := runtime.Caller(i)

		details := runtime.FuncForPC(pc)
		if ok && details != nil {
			fmt.Printf("%s%s (%s:%d)\n", strings.Repeat(" ", i), details.Name(), file, line) //nolint:forbidigo
		}
	}
}

// FindDevice returns the device from the given vSphere that has the given MOID.
// If no matching device is found, it returns nil.
func (m *Manager) FindDevice(ctx context.Context, vSphereHost, moid string) Device {
	// We specify a small max age here, because as metric gathering is done every minute,
	// there's a good chance to discover new vSphere VMs from the metric gathering.
	devices := m.Devices(ctx, 5*time.Minute)

	for _, dev := range devices {
		if dev.Source() == vSphereHost && dev.MOID() == moid {
			return dev
		}
	}

	return nil
}

type Device interface {
	// Kind returns whether this Device is a HostSystem or a VirtualMachine.
	Kind() string
	FQDN() string
	// Source returns the host address of the vCenter/ESXI from which this Device was described.
	Source() string
	// MOID returns the Managed Object ID of this Device,
	// which is an internal VMware identifier generated by vSphere.
	MOID() string
	Name() string

	Facts() map[string]string

	isPoweredOn() bool
	latestError() error
}

type device struct {
	// The source is the host address of the vCenter/ESXI from which this device was described.
	source     string
	moid       string
	name       string
	facts      map[string]string
	powerState string
	err        error
}

func (dev *device) FQDN() string {
	var domain string

	if dev.facts["domain"] != "" {
		domain = "." + dev.facts["domain"]
	}

	return dev.name + domain // TODO: slugify ?
}

func (dev *device) Source() string {
	return dev.source
}

func (dev *device) MOID() string {
	return dev.moid
}

func (dev *device) Name() string {
	return dev.name
}

// Facts returns the facts of this device, but ignores the given maxAge
// since the facts had been gathered at the same as the device itself.
func (dev *device) Facts() map[string]string {
	return dev.facts
}

func (dev *device) isPoweredOn() bool {
	return dev.powerState == "poweredOn"
}

func (dev *device) latestError() error {
	return dev.err
}

type HostSystem struct {
	device
}

func (host *HostSystem) Kind() string {
	return KindHost
}

type VirtualMachine struct {
	device
	UUID string
}

func (vm *VirtualMachine) Kind() string {
	return KindVM
}
