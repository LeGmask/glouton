package vsphere

import (
	"context"
	"fmt"
	"glouton/config"
	"glouton/crashreport"
	"glouton/inputs"
	"glouton/logger"
	"net/url"
	"sync"
	"time"

	"github.com/influxdata/telegraf"
)

const (
	KindHost = "HostSystem"
	KindVM   = "VirtualMachine"
)

type Manager struct {
	vSpheres map[string]*vSphere

	l                 sync.Mutex
	lastDevices       []Device
	lastDevicesUpdate time.Time
}

func (m *Manager) RegisterInputs(vSphereCfgs []config.VSphere, registerInput func(name string, input telegraf.Input, opts *inputs.GathererOptions, err error)) {
	m.vSpheres = make(map[string]*vSphere)

	for _, vSphereCfg := range vSphereCfgs {
		u, err := url.Parse(vSphereCfg.URL)
		if err != nil {
			logger.V(1).Printf("Failed to parse vSphere URL %q: %v", vSphereCfg.URL, err)

			continue
		}

		if _, alreadyExists := m.vSpheres[u.Host]; alreadyExists {
			continue
		}

		vSphere := &vSphere{host: u.Host, opts: vSphereCfg}

		input, opts, err := vSphere.makeInput()
		if err != nil {
			logger.Printf("Failed to create input %s: %v", vSphere.String(), err)

			continue
		}

		registerInput(vSphere.String(), input, opts, err)

		m.vSpheres[u.Host] = vSphere
	}
}

func (m *Manager) Devices(ctx context.Context, maxAge time.Duration) []Device {
	m.l.Lock()
	defer m.l.Unlock()

	if time.Since(m.lastDevicesUpdate) < maxAge {
		return m.lastDevices
	}

	logger.Printf("Discovering vSphere devices ...") // TODO: remove
	t0 := time.Now()

	deviceChan := make(chan Device)
	wg := new(sync.WaitGroup)

	for _, vSphere := range m.vSpheres {
		vSphere := vSphere

		wg.Add(1)

		go func() {
			defer crashreport.ProcessPanic()

			vSphere.devices(ctx, deviceChan)
			wg.Done()
		}()
	}

	go func() { wg.Wait(); close(deviceChan) }()

	var devices []Device

	for {
		device, ok := <-deviceChan
		if !ok {
			break // The channel has been closed
		}

		devices = append(devices, device)
	}

	m.lastDevices = devices
	m.lastDevicesUpdate = time.Now()

	logger.Printf("vSphere devices discovery done in %s", time.Since(t0)) // TODO: remove

	return devices
}

func (m *Manager) FindDevice(ctx context.Context, vSphereHost, moid string) Device {
	devices := m.Devices(ctx, time.Hour) // Or more than 1h ?

	for _, dev := range devices {
		if dev.Source() == vSphereHost && dev.MOID() == moid {
			return dev
		}
	}

	logger.Printf("Did not found vSphere device %q / %q", vSphereHost, moid) // TODO: remove

	return nil
}

type Device interface {
	// Kind returns whether this Device is a HostSystem or a VirtualMachine.
	Kind() string
	FQDN() string
	// Source returns the host address of the vCenter/ESXI from which this Device was described.
	Source() string
	// MOID returns the Managed Object ID of this Device,
	// which is an internal VMware identifier generated by vSphere.
	MOID() string

	Facts(ctx context.Context, maxAge time.Duration) (facts map[string]string, err error)
}

type device struct {
	// The source is the host address of the vCenter/ESXI from which this device was described.
	source string
	moid   string
	facts  map[string]string
}

func (dev *device) FQDN() string {
	return fmt.Sprintf("%s.%s", dev.source, dev.moid)
}

func (dev *device) Source() string {
	return dev.source
}

func (dev *device) MOID() string {
	return dev.moid
}

// Facts returns the facts of this device, but ignores the given maxAge
// since the facts had been gathered at the same as the device itself.
func (dev *device) Facts(_ context.Context, _ time.Duration) (map[string]string, error) {
	return dev.facts, nil
}

type HostSystem struct {
	device
}

func (host *HostSystem) Kind() string {
	return KindHost
}

type VirtualMachine struct {
	device
	UUID string
}

func (vm *VirtualMachine) Kind() string {
	return KindVM
}
