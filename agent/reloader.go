package agent

import (
	"context"
	"glouton/config"
	"glouton/debouncer"
	"glouton/logger"
	"strings"
	"sync"
	"time"

	"github.com/fsnotify/fsnotify"
)

const (
	reloadDebouncerDelay  = 5 * time.Second
	reloadDebouncerPeriod = 10 * time.Second
)

type agentReloader struct {
	watcher             *fsnotify.Watcher
	configFilesFromFlag []string

	l              sync.Mutex
	agentIsRunning bool
}

func StartReloadManager(watcher *fsnotify.Watcher, configFilesFromFlag []string) {
	defer watcher.Close()

	a := agentReloader{
		watcher:             watcher,
		agentIsRunning:      false,
		configFilesFromFlag: configFilesFromFlag,
	}

	a.run()
}

func (a *agentReloader) run() {
	// stopCtx is used to stop all the components.
	stopCtx, stopAll := context.WithCancel(context.Background())
	defer stopAll()

	// reloadCtx is used to stop all the components needing to be reloaded, some will
	// not be stopped like the Bleemeo MQTT connector to avoid reconnnecting.
	reloadCtx, stopReloadingComponents := context.WithCancel(stopCtx)
	defer stopReloadingComponents()

	// Start watching config files.
	reload := make(chan struct{}, 1)
	a.watchConfig(stopCtx, reload)

	// Run the agent for the first time.
	reload <- struct{}{}

	firstRun := true

	// Ticker used to stop the program if the agent is not running.
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	var (
		wgReload sync.WaitGroup
		wgStop   sync.WaitGroup
	)

	for {
		select {
		case <-reload:
			if !firstRun {
				logger.V(0).Printf("The config files have been modified, reloading agent...")

				stopReloadingComponents()
				wgReload.Wait()

				reloadCtx, stopReloadingComponents = context.WithCancel(context.Background())
				defer stopReloadingComponents()
			}

			wgReload.Add(1)

			a.l.Lock()
			a.agentIsRunning = true
			a.l.Unlock()

			go a.runAgent(stopCtx, reloadCtx, &wgReload, &wgStop, firstRun)

			firstRun = false
		case <-ticker.C:
			a.l.Lock()
			isRunning := a.agentIsRunning
			a.l.Unlock()

			if !isRunning {
				// Wait for all components to stop.
				stopAll()
				wgStop.Wait()

				return
			}
		}
	}
}

func (a *agentReloader) runAgent(stopCtx, reloadCtx context.Context, wgReload, wgStop *sync.WaitGroup, firstRun bool) {
	Run(stopCtx, reloadCtx, wgReload, wgStop, firstRun, a.configFilesFromFlag)

	a.l.Lock()
	a.agentIsRunning = false
	a.l.Unlock()
}

// watchConfig sends an event to the reload channel when the config has changed
// and the agent needs to be reloaded.
func (a *agentReloader) watchConfig(ctx context.Context, reload chan struct{}) {
	myConfigFiles := a.configFilesFromFlag
	if len(myConfigFiles) == 0 || len(myConfigFiles[0]) == 0 {
		// Get default config files.
		cfg := config.Configuration{}
		cfg.Set("config_files", defaultConfig()["config_files"])
		myConfigFiles = cfg.StringList("config_files")
	}

	// Use a debouncer because fsnotify events are often duplicated.
	reloadAgentTarget := func(ctx context.Context) {
		if ctx.Err() == nil {
			reload <- struct{}{}
		}
	}
	reloadDebouncer := debouncer.New(ctx, reloadAgentTarget, reloadDebouncerDelay, reloadDebouncerPeriod)

	go func() {
		for ctx.Err() == nil {
			select {
			case event, ok := <-a.watcher.Events:
				if !ok {
					return
				}

				// Only watch for write changes.
				if event.Op&fsnotify.Write != fsnotify.Write {
					continue
				}

				// Ignore temporary files generated by editors like .swp, ~.
				if !strings.HasSuffix(event.Name, ".conf") {
					continue
				}

				// Validate config before reloading.
				_, _, _, err := loadConfiguration(myConfigFiles, nil)
				if err == nil {
					reloadDebouncer.Trigger()
				}
			case err, ok := <-a.watcher.Errors:
				if !ok {
					return
				}

				logger.V(0).Printf("File watcher error: %v", err)
			case <-ctx.Done():
				return
			}
		}
	}()

	for _, file := range myConfigFiles {
		_ = a.watcher.Add(file)
	}
}
