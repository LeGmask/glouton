package zabbix

import (
	"bytes"
	"io"
	"reflect"
	"testing"
)

var versionRequest = []byte{0x5a, 0x42, 0x58, 0x44,
	0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}
var versionAnswer = []byte{0x5a, 0x42, 0x58, 0x44,
	0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x34, 0x2e, 0x32, 0x2e, 0x34}
var pingRequest = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x70, 0x69, 0x6e, 0x67}
var pingAnswer = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31}
var discRequest = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6e, 0x65, 0x74, 0x2e, 0x69, 0x66, 0x2e, 0x64,
	0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79} // net.if.discovery
var discAnswer = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5b, 0x7b, 0x22, 0x7b, 0x23, 0x49, 0x46, 0x4e,
	0x41, 0x4d, 0x45, 0x7d, 0x22, 0x3a, 0x22, 0x77,
	0x6c, 0x70, 0x32, 0x73, 0x30, 0x22, 0x7d, 0x2c,
	0x7b, 0x22, 0x7b, 0x23, 0x49, 0x46, 0x4e, 0x41,
	0x4d, 0x45, 0x7d, 0x22, 0x3a, 0x22, 0x76, 0x65,
	0x74, 0x68, 0x30, 0x61, 0x38, 0x30, 0x33, 0x61,
	0x64, 0x22, 0x7d, 0x2c, 0x7b, 0x22, 0x7b, 0x23,
	0x49, 0x46, 0x4e, 0x41, 0x4d, 0x45, 0x7d, 0x22,
	0x3a, 0x22, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72,
	0x30, 0x22, 0x7d, 0x2c, 0x7b, 0x22, 0x7b, 0x23,
	0x49, 0x46, 0x4e, 0x41, 0x4d, 0x45, 0x7d, 0x22,
	0x3a, 0x22, 0x76, 0x65, 0x74, 0x68, 0x33, 0x63,
	0x64, 0x33, 0x61, 0x34, 0x32, 0x22, 0x7d, 0x2c,
	0x7b, 0x22, 0x7b, 0x23, 0x49, 0x46, 0x4e, 0x41,
	0x4d, 0x45, 0x7d, 0x22, 0x3a, 0x22, 0x6c, 0x6f,
	0x22, 0x7d, 0x2c, 0x7b, 0x22, 0x7b, 0x23, 0x49,
	0x46, 0x4e, 0x41, 0x4d, 0x45, 0x7d, 0x22, 0x3a,
	0x22, 0x76, 0x65, 0x74, 0x68, 0x32, 0x30, 0x61,
	0x64, 0x34, 0x65, 0x61, 0x22, 0x7d, 0x2c, 0x7b,
	0x22, 0x7b, 0x23, 0x49, 0x46, 0x4e, 0x41, 0x4d,
	0x45, 0x7d, 0x22, 0x3a, 0x22, 0x76, 0x65, 0x74,
	0x68, 0x62, 0x63, 0x30, 0x39, 0x38, 0x31, 0x31,
	0x22, 0x7d, 0x5d}
var discString = `[{"{#IFNAME}":"wlp2s0"},{"{#IFNAME}":"veth0a803ad"},{"{#IFNAME}":"docker0"},{"{#IFNAME}":"veth3cd3a42"},{"{#IFNAME}":"lo"},{"{#IFNAME}":"veth20ad4ea"},{"{#IFNAME}":"vethbc09811"}]`
var inloRequest = []byte{0x5a, 0x42, 0x58, 0x44,
	0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6e, 0x65, 0x74, 0x2e, 0x69, 0x66, 0x2e,
	0x69, 0x6e, 0x5b, 0x6c, 0x6f, 0x5d} //net.if.in[lo]
var inloAnswer = []byte{0x5a, 0x42, 0x58, 0x44,
	0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x37, 0x39, 0x37, 0x38, 0x32, 0x36}
var cpuUtilRequest = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2e, 0x63,
	0x70, 0x75, 0x2e, 0x75, 0x74, 0x69, 0x6c, 0x5b,
	0x61, 0x6c, 0x6c, 0x2c, 0x75, 0x73, 0x65, 0x72,
	0x2c, 0x61, 0x76, 0x67, 0x31, 0x5d}
var cpuUtilAnswer = []byte{0x5a, 0x42, 0x58, 0x44, 0x01,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x33, 0x2e, 0x30, 0x30, 0x38, 0x31, 0x32, 0x33}

func TestDecode(t *testing.T) {
	cases := []struct {
		in   io.Reader
		want packetStruct
	}{
		{bytes.NewReader(versionRequest), packetStruct{version: 1, key: "agent.version"}},
		{bytes.NewReader(pingRequest), packetStruct{version: 1, key: "agent.ping"}},
		{bytes.NewReader(discRequest), packetStruct{version: 1, key: "net.if.discovery"}},
		{bytes.NewReader(inloRequest), packetStruct{1, "net.if.in", []string{"lo"}}},
		{bytes.NewReader(cpuUtilRequest), packetStruct{1, "system.cpu.util", []string{"all", "user", "avg1"}}},
	}
	for _, c := range cases {
		got, err := decode(c.in)
		if !reflect.DeepEqual(got, c.want) {
			t.Errorf("decode(zabbixPacket) == %v, want %v", got, c.want)
		}
		if err != nil {
			t.Error(err)
		}
	}
}

func TestSplitData(t *testing.T) {
	cases := []struct {
		in       string
		wantKey  string
		wantArgs []string
	}{
		{"key[a]", "key", []string{"a"}},
		{in: "key", wantKey: "key"},
		{"key[ ]", "key", []string{""}},
		{"key[a,]", "key", []string{"a", ""}},
		{`key["a","b","c"]`, "key", []string{"a", "b", "c"}},
		{"key[a,[b]]", "key", []string{"a", "b"}},
		{"key[a,[b,c]]", "key", []string{"a", "b,c"}},
		{`key["a","b",["c","d\",]"],[e,f]]`, "key", []string{"a", "b", `"c","d\",]"`, "e,f"}},
	}
	for _, c := range cases {
		gotKey, gotArgs := splitData(c.in)
		if gotKey != c.wantKey || !reflect.DeepEqual(gotArgs, c.wantArgs) {
			t.Errorf("splitData(%v) == %v+%v, want %v+%v", c.in, gotKey, gotArgs, c.wantKey, c.wantArgs)
		}
	}
}

func TestEncode(t *testing.T) {
	cases := []struct {
		in   packetStruct
		want []byte
	}{
		{packetStruct{version: 1, key: "1"}, pingAnswer},
		{packetStruct{version: 1, key: "4.2.4"}, versionAnswer},
		{packetStruct{version: 1, key: discString}, discAnswer},
		{packetStruct{version: 1, key: "797826"}, inloAnswer},
		{packetStruct{version: 1, key: "3.008123"}, cpuUtilAnswer},
	}
	for _, c := range cases {
		got, err := encodev1(c.in)
		if bytes.Compare(got, c.want) != 0 {
			t.Errorf("encodeV2(%v) == %v, want %v", c.in, got, c.want)
			break
		}
		if err != nil {
			t.Error(err)
		}
	}
}

type ReaderWriter struct {
	reader io.Reader
	writer *bytes.Buffer
}

func (rw ReaderWriter) Read(b []byte) (int, error) {
	return rw.reader.Read(b)
}
func (rw ReaderWriter) Write(b []byte) (int, error) {
	return rw.writer.Write(b)
}
func (rw ReaderWriter) Close() error {
	return nil
}

func responsev1(key string, args []string) string {
	if key == "agent.ping" {
		return "1"
	}
	if key == "agent.version" {
		return "4.2.4"
	}
	return ""
}

func TestHandleConnection(t *testing.T) {
	cases := []struct {
		in   ReaderWriter
		want []byte
	}{
		{ReaderWriter{bytes.NewReader(pingRequest), new(bytes.Buffer)}, pingAnswer},
		{ReaderWriter{bytes.NewReader(versionRequest), new(bytes.Buffer)}, versionAnswer},
	}
	for _, c := range cases {
		handleConnection(c.in, responsev1)
		got := c.in.writer.Bytes()
		if bytes.Compare(got, c.want) != 0 {
			t.Errorf("handleConnection(%v,response) writes %v, want %v", c.in, got, c.want)
			break
		}

	}
}
