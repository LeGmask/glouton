// Copyright 2015-2019 Bleemeo
//
// bleemeo.com an infrastructure monitoring solution in the Cloud
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"flag"
	"fmt"
	"glouton/agent"
	"glouton/debouncer"
	"glouton/logger"
	versionPkg "glouton/version"
	"strings"
	"sync"
	"time"

	_ "net/http/pprof" //nolint:gosec

	"github.com/fsnotify/fsnotify"
)

//nolint:gochecknoglobals
var (
	configFiles = flag.String("config", "", "Configuration files/dirs to load.")
	showVersion = flag.Bool("version", false, "Show version and exit")
)

//nolint:gochecknoglobals
var (
	version string
	commit  string
)

const (
	reloadDebouncerDelay  = 5 * time.Second
	reloadDebouncerPeriod = 10 * time.Second
)

// Watch config file changes and reload the agent.
func watchConfig(watcher *fsnotify.Watcher, agentReloader *debouncer.Debouncer) {
	myConfigFiles := strings.Split(*configFiles, ",")
	if len(myConfigFiles) == 0 || len(myConfigFiles[0]) == 0 {
		myConfigFiles = agent.DefaultConfigFiles()
	}

	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				// Only watch for write changes.
				if event.Op&fsnotify.Write != fsnotify.Write {
					continue
				}

				// Ignore temporary files generated by editors like .swp, ~.
				if !strings.HasSuffix(event.Name, ".conf") {
					continue
				}

				// Validate config before reloading.
				_, _, _, err := agent.LoadConfiguration(myConfigFiles, nil)
				if err == nil {
					fmt.Println(event)
					agentReloader.Trigger()
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}

				logger.V(0).Printf("File watcher error: %v", err)
			}
		}
	}()

	for _, file := range myConfigFiles {
		watcher.Add(file)
	}
}

func main() {
	if version != "" {
		versionPkg.Version = version
	}

	if commit != "" {
		versionPkg.BuildHash = commit
	}

	flag.Parse()

	if *showVersion {
		fmt.Println(versionPkg.Version) //nolint:forbidigo

		return
	}

	// Run os-specific initialisation code.
	OSDependentMain()

	// Start config file watcher, the agent is reloaded when a change is detected.
	watcherEnabled := true

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		logger.V(0).Printf("Could not watch config, Glouton will not be reloaded automatically on config change: %v", err)
		watcherEnabled = false
	}

	ctx, cancelAgent := context.WithCancel(context.Background())
	defer cancelAgent()

	var wg sync.WaitGroup

	wg.Add(1)
	go agent.Run(ctx, &wg, strings.Split(*configFiles, ","))

	if watcherEnabled {
		defer watcher.Close()

		// Use a debouncer because fsnotify events are often duplicated.
		ctxDebouncer, cancelDebouncer := context.WithCancel(context.Background())
		defer cancelDebouncer()

		reload := make(chan struct{})
		reloadAgentTarget := func(ctx context.Context) {
			if ctx.Err() == nil {
				reload <- struct{}{}
			}
		}
		agentReloader := debouncer.New(ctxDebouncer, reloadAgentTarget, reloadDebouncerDelay, reloadDebouncerPeriod)

		watchConfig(watcher, agentReloader)

		for range reload {
			logger.V(0).Printf("The config files have been modified, reloading agent...")
			cancelAgent()
			wg.Wait()

			ctx, cancelAgent = context.WithCancel(context.Background())
			defer cancelAgent()

			wg.Add(1)
			go agent.Run(ctx, &wg, strings.Split(*configFiles, ","))
		}
	}

	wg.Wait()
}
